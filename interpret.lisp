(defun get_interpreter_meta_level () 
  __interpreter_meta_level)
;; native definition of function "sexps_str" omitted

(defun ps (form) 
  (print (sexps_str form)))

(defmacro debug (&rest args)
  (when (> (get_interpreter_meta_level) 0)
    `(print ~@args)))

(def TYPE "__type")
(def TYPE_T "__type_t")
;; native definition of function "is_int" omitted

;; native definition of function "is_float" omitted

;; native definition of function "is_str" omitted

(defun is_num (f) (or (is_int f) (is_float f)))
;; native definition of function "is_tuple" omitted

;; native definition of function "is_dict" omitted

;; native definition of function "__defstruct" omitted

;; native definition of function "is_struct" omitted

(defun is_named_operator (form op) 
  (assert (is_symbol op)) 
  (and (is_list form) 
       form
       (is_symbol (1st form)) 
       (eq (1st form) op)))
(let* ((__gensym-let-value-4 (__defstruct "special-form" "fun"))) 
  (def special_form (aref __gensym-let-value-4 0)) 
  (def is_special_form (aref __gensym-let-value-4 1)) 
  (def special_form_fun (aref (aref __gensym-let-value-4 2) 0)) 
  (def _ (aref __gensym-let-value-4 3)))
(let* ((__gensym-let-value-5 (__defstruct "macro" "fun"))) 
  (def macro (aref __gensym-let-value-5 0)) 
  (def is_macro (aref __gensym-let-value-5 1)) 
  (def macro_fun (aref (aref __gensym-let-value-5 2) 0)) 
  (set _ (aref __gensym-let-value-5 3)))
(defun is_atom (form) 
  (or (is_num form) 
      (is_str form) 
      (is_keyword form) 
      (is_symbol form) 
      (and (is_list form) 
           (not (length form)))))
(defun keyword (s) 
  (assert (is_str s) 
          (sexps_str s)) 
  (intern (+ keyword_start s)))
(defun keyword_name (s) 
  (assert (is_keyword s) s) 
  (slice (symbol_name s) 
         (length keyword_start) nil))
(defun is_keyword (e) 
  (and (is_symbol e) 
       ((. (symbol_name e) startswith) keyword_start)))
(defun is_special_keyword (e) 
  (and (is_symbol e) 
       ((. (symbol_name e) startswith) "&")))
;; native definition of function "is_iterable" omitted

;; native definition of function "is_list" omitted

;; native definition of function "length" omitted

;; native definition of function "as_list" omitted

;; native definition of function "is_callable" omitted

;; native definition of function "Env" omitted

;; native definition of function "is_env" omitted

;; native definition of function "env_d" omitted

;; native definition of function "env_parent" omitted

(defun make_env ((parent nil)) 
  (Env (dict) parent))
(defun env_contains (env k) 
  (assert (is_symbol k) k) 
  (assert (is_env env)) 
  (or (member? k (env_d env)) 
      (and (env_parent env) 
           (env_contains (env_parent env) k))))
(defun env_get (env k) 
  (assert (is_symbol k) k) 
  (assert (is_env env)) 
  (while (is-not env nil) 
    (let* ((d (env_d env))) 
      (if (member? k d) 
          (return (aref d k)) 
        (set env (env_parent env))))) 
  (throw 'env-error k))
(defun env_containing_parent (env k) 
  (assert (is_symbol k) k) 
  (assert (is_env env)) 
  (while (and env 
              (not-member? k (env_d env))) 
    (set env (env_parent env)))
  env)
(defun env_def (env k v) 
  (assert (is_symbol k) k) 
  (assert (is_env env)) 
  (let* ((d (env_d env))) 
    (assert (not (member? k d)) 
            ((. "{k} in {d}" format) :k k 
             :d (env_d env)))) 
  (setf (aref (env_d env) k) v))
(defun env_change (env k v) 
  (assert (is_symbol k) k) 
  (set env (or (env_containing_parent env k) 
               env)) 
  (setf (aref (env_d env) k) v))
(def symbols (dict))
;; native definition of function "symbol" omitted

;; native definition of function "is_symbol" omitted

;; native definition of function "symbol_name" omitted

;; native definition of function "intern" omitted

(def gensym_counter (- 1))
;; native definition of function "gensym" omitted

(def whitespace " \t\n")
(def newlines "\n")
(def token_end_chars (+ whitespace ")"))
(def keyword_start ":")
(def floating_point ".")
(def str_start "\"")
(def str_end "\"")
(def accessor_char ".")
(def quote_char "'")
(def backquote_char "`")
(def backquote_eval_char "~")
(def backquote_splice_char "~@")
(def comment_chars (tuple ";"))
(def escape_chars "\\")
(def special_chars (dict :n "\n" 
                         :t "\t"))
(def quote_fun_name "quote")
(def backquote_fun_name "backquote")
(def backquote_eval_fun_name "unquote")
(def backquote_splice_fun_name "unquote-splice")
(def return_name "return")
(def return_sym (intern return_name))
(def accessor_char_sym (intern accessor_char))
(def variadic_name "&rest")
(def keys_name "&keys")
(def nokeys_name "&nokeys")
(def nokeys_sym (intern nokeys_name))
(def quote_fun_sym (intern quote_fun_name))
(def backquote_fun_sym (intern backquote_fun_name))
(def backquote_eval_fun_sym (intern backquote_eval_fun_name))
(def backquote_splice_fun_sym (intern backquote_splice_fun_name))
(def global_env_sym (intern "*global-env*"))
(def VALID "__VALID")
(def RETURN "__RETURN")
(def FAILED "__FAILED")
(defun Valid (expr) 
  (tuple VALID expr))
(defun Return (expr) 
  (tuple RETURN expr))
(defun Failed () 
  (tuple FAILED nil))
(def VALID_ACTIONS (tuple VALID RETURN))
(defun ends_token (s) 
  "assumes that all tokens are ended by one of token_end_chars"
  (member? (stream_peek s) token_end_chars))
(defun is_paren_open (c) 
  (eq c "("))
(defun is_paren_close (c) 
  (eq c ")"))
(defun is_whitespace (c) 
  (member? c " \n\t"))
(defun Stream (source pos) 
  (dict :source source 
        :pos pos))
(defun stream_source (self) 
  (aref self "source"))
(defun stream_pos (self) 
  (aref self "pos"))
(defun stream_pos_set (self pos) 
  (setf (aref self "pos") pos))
(defun stream_token (self a b) 
  (slice (stream_source self) a b))
(defun stream_peek (self) 
  (aref (stream_source self) 
        (stream_pos self)))
(defun stream_next (self) 
  (let* ((c (aref (stream_source self) 
                  (stream_pos self)))) 
    (stream_pos_set self (+ (stream_pos self) 1)) 
    (return c)))
(defun stream_advance (self n) 
  (stream_pos_set self (+ (stream_pos self) n)))
(defun stream_empty (self) 
  (>= (stream_pos self) 
      (length (stream_source self))))
(defun next_token_is (reader s) 
  (neq (reader s) 0))
(defun read_list (s) 
  (if (or (stream_empty s) 
          (not (is_paren_open (stream_next s)))) 
      (return (Failed)) 
    (progn 
      (defun read_list_end (s) 
        (when (or (stream_empty s) 
                  (not (is_paren_close (stream_next s)))) 
          (return (Failed))) 
        (Return nil)) 
      (let* ((els (read s 
                        :readers (+ (list read_list_end) readers)))) 
        (return (Valid els))))))
(defun _read_int (s) 
  (let* ((istart (stream_pos s)) 
         (unary 0)) 
    (when (and (not (stream_empty s)) 
               (member? (stream_peek s) 
                        (tuple "-" "+"))) 
      (stream_next s) 
      (set unary 1)) 
    (while (and (not (stream_empty s)) 
                (member? (stream_peek s) "0123456789")) 
      (stream_next s)) 
    (return (< (+ istart unary) 
               (stream_pos s)))))
(defun read_num (s) 
  (let* ((istart (stream_pos s)) 
         (parsed (_read_int s)) 
         (num int)) 
    (when (and (not (stream_empty s)) 
               (member? (stream_peek s) floating_point)) 
      (stream_next s) 
      (set parsed (_read_int s)) 
      (set num float)) 
    (set parsed (and parsed 
                     (or (stream_empty s) 
                         (ends_token s)))) 
    (when parsed 
      (set s (stream_token s istart (stream_pos s))) 
      (return (Valid (num s))))) 
  (Failed))
(defun read_str (s) 
  (when (member? (stream_peek s) str_start) 
    (stream_next s) 
    (let* ((r "") 
           (escape_open false)) 
      (while (and (not (stream_empty s)) 
                  (or (not-member? (stream_peek s) str_end) 
                      escape_open)) 
        (let* ((c (stream_next s))) 
          (if (member? c escape_chars) 
              (progn (when escape_open (+= r c)) 
                     (set escape_open (not escape_open))) 
            (progn (when (and escape_open 
                              (member? c special_chars)) 
                     (set c (aref special_chars c))) 
                   (+= r c) 
                   (set escape_open false))))) 
      (unless (stream_empty s) 
        (stream_next s) 
        (return (Valid r))))) 
  (Failed))
(defun read_whitespace (s) 
  (let* ((parsed nil)) 
    (while (and (not (stream_empty s)) 
                (member? (stream_peek s) whitespace)) 
      (stream_next s) 
      (set parsed true)) 
    (return (if parsed (Valid nil) 
              (Failed)))))
(defun read_comment (s) 
  (when (not-member? (stream_next s) comment_chars) 
    (return (Failed))) 
  (while (and (not (stream_empty s)) 
              (not-member? (stream_peek s) newlines)) 
    (stream_next s)) 
  (Valid nil))
(defun read_symbol (s) 
  (let* ((istart (stream_pos s))) 
    (while (not (or (stream_empty s) 
                    (ends_token s))) 
      (stream_next s)) 
    (when (neq (stream_pos s) istart) 
      (let* ((token (stream_token s istart (stream_pos s)))) 
        (defun resp () 
          (Valid (intern token))) 
        (if (not-member? accessor_char token) 
            (return (resp)) 
          (progn (when (eq token accessor_char) 
                   (return (resp))) 
                 (let* ((accessors (token.split accessor_char))) 
                   (when (any (map (fn (a) 
                                       (eq a "")) accessors)) 
                     (return (resp))) 
                   (set accessors (filter (fn (a) a) accessors a)) 
                   (return (Valid (+ (list accessor_char_sym) 
                                     (map (fn (s) 
                                              (intern s)) accessors)))))))))) 
  (Failed))
(defun read_quote_like (s quote_char quote_call_sym) 
  (dolist (c quote_char) 
    (when (neq (stream_next s) c) 
      (return (Failed)))) 
  (let* ((expr (read s 
                     :one true)) 
         (r (+ (list quote_call_sym) expr)))) 
  (Valid r))
(defun read_quote (s) 
  (read_quote_like s quote_char quote_fun_sym))
(defun read_backquote (s) 
  (read_quote_like s backquote_char backquote_fun_sym))
(defun read_backquote_eval (s) 
  (read_quote_like s backquote_eval_char backquote_eval_fun_sym))
(defun read_backquote_splice (s) 
  (read_quote_like s backquote_splice_char backquote_splice_fun_sym))
(def readers (list read_list read_whitespace read_comment read_num read_str read_backquote_splice
                   read_backquote_eval read_quote read_backquote read_symbol))
;; native definition of function "read" omitted

(py-import operator)
(py-import inspect)
;; native definition of function "BlockException" omitted

(defun format_operator_call (fun args) 
  (set args (map (fn (a) 
                     (sexps_str a)) args)) 
  ((. "({fun} {args})" format) :fun fun 
   :args ((. " " join) args)))
(def callstack (list))
(defun callstack_str () 
  (let* ((max_n 50) 
         (long (> (length callstack) max_n)) 
         (partial_callstack (if long (reversed (slice (as-list (reversed callstack)) nil max_n))
                              callstack)) 
         (indent (* "### " (+ 1 (get_interpreter_meta_level))))) 
    (defun stack_line (f args) 
      (+ indent (format_operator_call (sexps_str f) args))) 
    (let* ((stack_strs (map (fn (line) 
                                (apply stack_line line)) partial_callstack)) 
           (msg nil)) 
      (if long 
          (set msg ((. "<truncated {num} entries>" format) :num (- (length callstack) max_n))) 
        (set msg "<beginning>")) 
      (let* ((r ((. "\n" join) 
                 (+ (+ (list (+ indent msg)) stack_strs) 
                    (list (+ indent "<end>")))))) 
        (return r)))))
(defun make_error_msg (msg &keys kwargs) 
  (let* ((s "Traceback (most recent call last):\n{stack}\n{msg}"))) 
  (s.format :stack (callstack_str) 
            :msg (apply msg.format (fold (fn (args k) 
                                             (assert (str? k) 
                                                     (repr k)) 
                                             (+ args (list (+ (keyword k)) 
                                                           (aref kwargs k)))) 
                                         (list) 
                                         (as-list (dict-keys kwargs))))))
(defun defstruct (env name &rest fields) 
  (assert (is_symbol name) 
          ((. "defstruct: {s}" format) :s name)) 
  (let* ((name_str (symbol_name name)) 
         (field_names (map (fn (f) 
                               (symbol_name f)) fields)) 
         (__gensym-let-value-0 (apply __defstruct ` (~ name_str ~@ field_names))) 
         (constructor (aref __gensym-let-value-0 0)) 
         (is_instance (aref __gensym-let-value-0 1)) 
         (getter (aref __gensym-let-value-0 2)) 
         (setter (aref __gensym-let-value-0 3))) 
    (env_def env name constructor) 
    (let* ((fname (mod "%s?" name_str))) 
      (env_def env (intern fname) is_instance)) 
    (dolist ((:= field get) 
             (zip field_names getter)) 
      (let* ((gname (mod "%s-%s" (tuple name_str field)))) 
        (env_def env (intern gname) get))) 
    (dolist ((:= field set) 
             (zip field_names setter)) 
      (let* ((sname (mod "%s-%s-set" (tuple name_str field)))) 
        (env_def env (intern sname) set))))
  constructor)

(def block-tag 'block-tag)

(defun block-tag? (v)
  (and (list? r)
       r
       (__is (car r) name)))

(defun __block (env name &rest body)
  (let* ((r `(catch ~block-tag ~@body)))
    (assert (block-tag? r) r)
    (unless (__is (2nd r) name)
        (throw block-tag r))))

;; native definition of function "return_from" omitted

(defun parameter_default (p) 
  (2nd p))
(defun is_parameter_with_default_ (p) 
  (and (is_list p) 
       (eq (length p) 2) 
       (is_symbol (1st p))))
(defun is_simple_parameter (p) 
  (and (is_symbol p) 
       (not (is_keyword p)) 
       (not (is_special_keyword p))))
(defun is_normal_parameter (p) 
  (or (is_simple_parameter p) 
      (is_parameter_with_default_ p)))
(defun normal_parameter_name (p) 
  (if (is_parameter_with_default_ p) 
      (return (1st p)) 
    (return p)))
(let* ((function-funs (__defstruct "function" "name" "env" "parameters" "varargs_name"
                                   "keysargs_name" "nokeys" "block_name" "body"))
       (function-getters (3rd function-funs))
       (function-setters (4th function-funs))) 
  (def function (aref function-funs 0)) 
  (def is_function (aref function-funs 1)) 
  (def function_name (aref function-getters 0)) 
  (def function_env (aref function-getters 1)) 
  (def function_parameters (aref function-getters 2)) 
  (def function_varargs_name (aref function-getters 3)) 
  (def function_keysargs_name (aref function-getters 4)) 
  (def function_nokeys (aref function-getters 5)) 
  (def function_block_name (aref function-getters 6)) 
  (def function_body (aref function-getters 7)) 
  (def function_set_name (aref function-setters 0)))
(defun __fn (env parameters (name nil) &rest body) 
  (let* ((valid_specials 
          (Set variadic_name keys_name nokeys_name)) 
         (special_used 
          (set)) 
         (special_allows_next 
          (Set variadic_name keys_name)) 
         (special_end_only 
          (Set variadic_name keys_name)) 
         (special_once_only 
          (Set variadic_name keys_name nokeys_name)) 
         (parsed_parameters (list)) 
         (special_param_names (dict))) 
    (setf (aref special_param_names variadic_name) nil) 
    (setf (aref special_param_names keys_name) nil) 
    (let* ((varargs_param false) 
           (kwargs_param false) 
           (used_names 
            (set)) 
           (i 0) 
           (end false))) 
    (while (< i (length parameters)) 
      (let* ((iparam i) 
             (param (aref parameters i)) 
             (param_name nil) 
             (param_default nil) 
             (param_special nil) 
             (is_last (>= (+ i 1) 
                          (length parameters))) 
             (next_param (if (not is_last) 
                             (aref parameters (+ i 1)) nil)) 
             (has_normal_next (and (not is_last) 
                                   next_param
                                   (is_normal_parameter next_param))))) 
      (when (is_special_keyword param) 
        (set param_special (symbol_name param)) 
        (set param nil) 
        (when (not-member? param_special valid_specials) 
          (throw 'special-keyword-error (make_error_msg "Unknown special keyword: {s} at position {i}" 
                                           :s p 
                                           :i i))) 
        (when (member? param_special special_param_names) 
          (setf (aref special_param_names param_special) true)) 
        (when (member? param_special special_allows_next) 
          (when has_normal_next (+= i 1) 
                (when (member? param_special special_param_names) 
                  (setf (aref special_param_names param_special) next_param)))) 
        (when (and (member? param_special special_once_only) 
                   (member? param_special special_used)) 
          (throw 'special-keyword-error (make_error_msg "{special} parameter defined more than once" 
                                           :special param_special))) 
        (cond ((member? param_special special_end_only) 
               (set end true)) 
              (end 
               (throw 'special-keyword-error (make_error_msg
                                 "{special} parameters must be defined after normal ones" 
                                 :special param_special)))) 
        (when (is-not param_special nil) 
          (special_used.add param_special))) 
      (when param 
        (set param_name (normal_parameter_name param)) 
        (when (is_parameter_with_default_ param) 
          (set param_default (parameter_default param)) 
          (defun make_default_constructor (param_default) 
            (defun constructor () 
              (__eval env param_default))
            constructor) 
          (set param_default (make_default_constructor param_default)))) 
      (when param_name (when (member? (symbol_name param_name) used_names) 
                         (throw 'parameter-error (make_error_msg "Duplicate parameter {name}" 
                                                          :name n))) 
            (used_names.add (symbol_name param_name)) 
            (assert (is_symbol param_name) param_name) 
            (parsed_parameters.append (tuple param_name param_default))) 
      (+= i 1))) 
  (let* ((block_name (gensym "fn")) 
         (varargs_name (aref special_param_names variadic_name)) 
         (keysargs_name (aref special_param_names keys_name)) 
         (nokeys (member? nokeys_name special_used)) 
         (assert (list? body) (repr body))
         (user_function (function name env parsed_parameters varargs_name keysargs_name nokeys
                                  block_name body))))
  user_function)
(defun __defun (env name parameters &rest body) 
  (assert (is_symbol name) 
          ((. "defun: {s}" format) :s name)) 
  (let* ((name_str (symbol_name name)) 
         (f (apply __fn ` (~ env ~ parameters ~ name ~@ body))))) 
  (env_def env name f)
  f)
(defun __defmacro (lexical_env name parameters &rest body) 
  (assert (is_symbol name) 
          ((. "{i}: {call}" format) :i (get_interpreter_meta_level) 
           :call (format_operator_call "__defmacro" (+ (list lexical_env name parameters) 
                                                       (as-list body))))) 
  (when (env_contains lexical_env name) 
    (throw 'definition-error (make_error_msg "fun {fun} already declared" 
                                     :fun (symbol_name name)))) 
  (let* ((f (apply __fn ` (~ lexical_env ~ parameters ~ name ~@ body))) 
         (m (macro f)))) 
  (env_def lexical_env name m)
  m)
(defun __apply (env f_form args) 
  (let* ((f (__eval env f_form))) 
    (callstack.append (tuple (if (is_function f) 
                                 (function_name f) 
                               (host_function_name f)) 
                             (list args))) 
    (let* ((evaled_args (__eval env args)) 
           (r (__call env f evaled_args 
                      :do_eval_args false))))) 
  (callstack.pop)
  r)
(defun __sub_env (env &rest body) 
  (let* ((sub_env (make_env env))) 
    (return (apply __progn ` (~ sub_env ~@ body)))))
(defun __let (env vars &rest let_body) 
  (dolist (var vars) 
    (assert (is_list var) 
            (sexps_str var)) 
    (assert (eq (length var) 2)) 
    (assert (is_symbol (1st var)) 
            (sexps_str var))) 
  (let* ((let_env (make_env env))) 
    (dolist (var vars) 
      (let* ((__gensym-let-value-1 var) 
             (name_sym (aref __gensym-let-value-1 0)) 
             (body (aref __gensym-let-value-1 1)) 
             (val (__eval let_env body)))) 
      (setf (aref (env_d let_env) name_sym) val)) 
    (return (apply __progn ` (~ let_env ~@ let_body)))))
;; native definition of function "__if" omitted

(defun __def (env name &rest args) 
  (let* ((val (if args (__eval env (1st args)) nil))) 
    (assert (is_symbol name) 
            ((. "def: {s}" format) :s name)) 
    (set env (env_get env global_env_sym)) 
    (when (env_contains env name) 
      (throw 'definition-error (make_error_msg "var {var} already declared in global env" 
                                       :var (symbol_name name)))) 
    (env_def env name val) 
    (return val)))
(defun __setq (env name value) 
  (assert (is-not env nil)) 
  (assert (is_symbol name) 
          ((. "set: {s}" format) :s name)) 
  (set value (__eval env value)) 
  (when (is_function value) 
    (function_set_name value name)) 
  (env_change env name value)
  value)
;; native definition of function "py_get_param_names" omitted

(def native_functions (dict))
;; native definition of function "native_set_nokeys" omitted

;; native definition of function "is_native_function" omitted

;; native definition of function "is_native_builtin" omitted

;; native definition of function "get_native_function_id" omitted

;; native definition of function "host_function_name" omitted

;; native definition of function "host_function_nokeys" omitted

;; native definition of function "is_host_function" omitted

;; native definition of function "call_host_function" omitted

(defun call_function (fun args_forms nokeys unevaled_args_forms) 
  (let* ((is_host_fun false)) 
    (if (is_function fun) 
        (set nokeys (or nokeys 
                        (function_nokeys fun))) 
      (progn (assert (is_host_function fun) fun) 
             (set nokeys (or nokeys 
                             (host_function_nokeys fun))) 
             (set is_host_fun true))) 
    (let* ((iparam 0) 
           (parsed_args (list)) 
           (kwargs (dict)) 
           (remaining_args args_forms) 
           (keywords_started false)) 
      (while remaining_args
        (let* ((arg (1st remaining_args))) 
          (set remaining_args (tail remaining_args)) 
          (if (and (is_keyword arg) 
                   remaining_args
                   (not nokeys)) 
              (progn 
                (set keywords_started true) 
                (let* ((key (keyword_name arg))) 
                  (set arg (remaining_args.pop 0)) 
                  (setf (aref kwargs key) arg))) 
            (progn (when keywords_started 
                     (throw 'argument-error (make_error_msg ((.
                                                              "positional argument follows keyword argument {call}"
                                                              format) :call
                                                              (format_operator_call fun
                                                                                    args_forms))))) 
                   (parsed_args.append arg)))) ;; del omitted
        ) 
      (if is_host_fun (return (call_host_function fun parsed_args kwargs)) 
        (progn (let* ((function_repr (or (function_name fun) 
                                         "<fn>")) 
                      (parameters (function_parameters fun)) 
                      (set_varargs function_varargs_name) 
                      (set_kwargs function_keysargs_name)) 
                 (defun call_make_error (err) 
                   (+ err ((.
                            "\nin function call:\n    {call}\nevaled to:\n    {evaled_args} \nparsed as:\n    {parsed_args}\nfunction expects:\n    {params} &rest {varargs} &keys {kwargs}."
                            format) :call (format_operator_call function_repr unevaled_args_forms) 
                            :parsed_args (format_operator_call function_repr parsed_args) 
                            :evaled_args (format_operator_call function_repr args_forms) 
                            :kwargs set_kwargs 
                            :params (sexps_str parameters) 
                            :varargs (repr set_varargs)))) 
                 (when (and (not set_varargs) 
                            (> (length parsed_args) 
                               (length parameters))) 
                   (throw 'argument-error (make_error_msg (call_make_error ((.
                                                             "too many arguments (#{n} vs #{m})"
                                                             format) :n (length parameters) 
                                                             :m (length parsed_args)))))) 
                 (when (< (length parsed_args) 
                          (length parameters)) 
                   (dolist ((:= i p) 
                            (enumerate (slice parameters (length parsed_args) nil))) 
                     (assert (isinstance p tuple) p) 
                     (let* ((__gensym-let-value-2 p) 
                            (param_name (aref __gensym-let-value-2 0)) 
                            (param_default (aref __gensym-let-value-2 1)) 
                            (n (symbol_name param_name)) 
                            (in_kwargs (member? n kwargs)))) 
                     (when (and (not in_kwargs) 
                                (is param_default nil)) 
                       (throw 'argument-error (make_error_msg (call_make_error ((.
                                                                           "function call missing argument \"{name}\"{default}"
                                                                           format) :name n 
                                                                           :default (if param_default
                                                                                        ((.
                                                                                          "(:= {d})"
                                                                                          format) :d
                                                                                          (param_default))
                                                                                      "")))))) 
                     (parsed_args.append (if in_kwargs (aref kwargs n) 
                                           (param_default))) 
                     (when in_kwargs ;; del omitted
                       ))) 
                 (when (> (length parameters) 
                          (length parsed_args)) 
                   (throw 'argument-error (make_error_msg "function call missing argument \"{i}\": {call}" 
                                                    :i (symbol_name (1st (aref parameters (length
                                                                                           parsed_args)))) 
                                                    :fun (format_operator_call function_repr
                                                                               unevaled_args_forms)))) 
                 (when (and (not set_kwargs) 
                            kwargs) 
                   (throw 'argument-error (make_error_msg
                                     "Unexpected keyword arguments for function call: ({fun} {params} {kwargs}) called with {args}" 
                                     :fun function_repr 
                                     :args (sexps_str parsed_args_forms) 
                                     :params (sexps_str parameters) 
                                     :kwargs (sexps_str kwargs)))) 
                 (let* ((varargs (list))) 
                   (when (and set_varargs 
                              (> (length parsed_args) 
                                 (length parameters))) 
                     (set varargs (slice parsed_args (length parameters) nil)) 
                     (set parsed_args (slice parsed_args nil (length parameters)))) 
                   (defun user_function (fun args varargs kwargs) 
                     (let* ((fun_def_env (function_env fun)) 
                            (fun_env (make_env fun_def_env)) 
                            (block_name (function_block_name fun)) 
                            (return_fun (special_form (fn (call_env (value nil)) 
                                                          (return_from call_env block_name value))))) 
                       (env_def fun_env return_sym return_fun) 
                       (dolist ((:= (parameter default) arg) 
                                (zip (function_parameters fun) args)) 
                         (env_def fun_env parameter arg)) 
                       (let* ((varargs_name (function_varargs_name fun))) 
                         (when (is_symbol varargs_name) 
                           (env_def fun_env varargs_name varargs))) 
                       (let* ((keysargs_name (function_keysargs_name fun))) 
                         (when (is_symbol keysargs_name) 
                           (env_def fun_env keysargs_name kwargs))) 
                       (let* ((body (function_body fun))) 
                         (return (apply __block (cons fun_env (cons block_name body)))))))
                   
                   (return (user_function fun parsed_args varargs kwargs)))))))))
(defun __call_function (env fun args_forms eval) 
  (let* ((nokeys false) 
         (first_arg (if args_forms (1st args_forms) nil))) 
    (when (eq first_arg nokeys_sym) 
      (set nokeys true) 
      (args_forms.pop 0)) 
    (let* ((unevaled_args_forms args_forms)) 
      (when eval 
        (set args_forms (map (fn (arg) 
                                 (__eval env arg)) args_forms))) 
      (return (call_function fun args_forms nokeys unevaled_args_forms)))))
(defun __macroexpand_1 (env fun args_forms) 
  (__call_function env fun args_forms 
                   :eval false))
(defun __macroexpand (env fun args_forms) 
  (let* ((form (__macroexpand_1 env fun args_forms))) 
    (while (and (is_operator_call form) 
                (is_macro (1st form))) 
      (set form (apply __macroexpand_1 ` (~ env ~@ form)))) 
    (return form)))
(defun __call (env fun args_forms do_eval_args) 
  (cond ((is_special_form fun) 
         (set fun (special_form_fun fun)) 
         (debug (fn () 
                    (repr fun))) 
         (let* ((r (__macroexpand_1 env fun (+ (list env) args_forms)))) 
           (return r))) 
        ((is_macro fun) 
         (set fun (macro_fun fun)) 
         (let* ((form (__macroexpand env fun args_forms)) 
                (r (__eval env form)))) 
         (return r)) 
        ((or 
          (is_function fun) 
          (is_callable fun)) 
         (return (__call_function env fun args_forms do_eval_args))) 
        (true 
         (throw 'eval-error (make_error_msg "({fun} {args}) is not callable" 
                                :fun (repr fun) 
                                :args (if args_forms (sexps_str args_forms) ""))))))
(defun is_operator_call (form) 
  (and (is_list form) 
       form))
(defun __eval (env form) 
  (debug "******** eval :" (fn () 
                               (sexps_str form))) 
  (let* ((r nil)) 
    (cond ((and 
            (is_symbol form) 
            (not (is_keyword form))) 
           (unless (env_contains env form) 
             (defun print_env_keys (env) 
               (set r (list)) 
               (while (is-not env nil) 
                 (+= r (list (+ "Keys: " ((. " " join) 
                                          (sorted (map symbol_name (as_list ((. (env_d env)
                                                                                keys))))))))) 
                 (set env (env_parent env))) 
               ((. "\n" join) r)) 
             (throw 'eval-error (make_error_msg "Symbol \"{sym}\" not found in env \n{keys}" 
                                           :sym (symbol_name form) 
                                           :keys (print_env_keys env)))) 
           (set r (env_get env form))) 
          ((is_atom form) 
           (set r form)) 
          ((is_operator_call form) 
           (let* ((args_forms (tail form))) 
             (callstack.append (tuple (1st form) args_forms)) 
             (let* ((fun (__eval env (1st form)))) 
               (assert (or (is_macro fun) 
                           (is_special_form fun) 
                           (is_function fun) 
                           (is_callable fun)) fun) 
               (set r (__call env fun args_forms 
                              :do_eval_args true)))) 
           (callstack.pop)) 
          (true 
           (throw 'eval-error (make_error_msg "unknown form: {form}" 
                                            :form (sexps_str form))))) 
    (debug "******** eval returning:" (fn () 
                                          (repr form))) 
    (return r)))
(defun base_env ((args (list))) 
  (debug "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CREATING BASEENV for interpreter"
         (get_interpreter_meta_level)) 
  (let* ((env (make_env))) 
    (env_def env (intern "__interpreter_meta_level") 
             (+ (get_interpreter_meta_level) 1)) 
    (defun bind (name value) 
      (assert (is_str name) name) 
      (env_def env (intern name) value)) 
    (defun bindn 
        (&rest 
         args) 
      (assert (>= (length args) 2) args) 
      (let* ((names (slice args nil (- 1))) 
             (value (aref args (- 1)))) 
        (dolist (name names) 
          (bind name value)))) 
    (bind "true" true) 
    (bind "false" false) 
    (bind "nil" nil) 
    (bind "type" type) 
    (bind "sorted" sorted) 
    (bindn "as-list" "as_list" as_list) ;; native definition of function "list_set" omitted
    (bindn "list-set" "list_set" list_set) ;; native definition of function "append" omitted
    (bind "append" append) ;; native definition of function "extend" omitted
    (bind "extend" extend) 
    (bind "aref" (fn (l k) 
                     (aref l k))) 
    (bind "intern" intern) 
    (bind "symbol" symbol) 
    (bindn "symbol-name" "symbol_name" symbol_name) 
    (bind "keyword" keyword) 
    (bind "keyword-name" keyword_name) 
    (bind "Env" Env) 
    (bind "is_env" is_env) 
    (bind "env_d" env_d) 
    (bind "env_parent" env_parent) ;; native definition of function "dict_set" omitted
    (bindn "dict-set" "dict_set" dict_set) ;; native definition of function "dict_keys" omitted
    (bindn "dict-keys" "dict_keys" dict_keys) ;; native definition of function "__while" omitted
    ;; native definition of function "__assert" omitted
    (bindn "assert" "__assert" (special_form __assert))
    (bind "__block" (special_form __block))
    (bindn "__if" "if" (special_form __if)) 
    (bind "__while" (special_form __while)) 
    (let* ((return_from_special (special_form return_from))) 
      (bind "return_from" return_from_special) 
      (bind "return-from" return_from_special)) 
    (bind "let*" (special_form __let)) 
    (defun native_binds () 
      (bind "list" list) 
      (bind "tuple" tuple) 
      (bind "dict" dict) 
      (bind "dict_setdefault" dict_setdefault) 
      (bind "dict-setdefault" dict_setdefault)) ;; native definition of function "native_binds" omitted
    (native_binds) 
    (defun set_nokeys_from_env (name) 
      (let* ((f (env_get env name))) 
        (native_set_nokeys f true))) 
    (set_nokeys_from_env (intern "list")) 
    (set_nokeys_from_env (intern "tuple")) 
    (native_set_nokeys __defmacro true) 
    (defun __import (env &rest args)) 
    (bind "import" (special_form __import)) ;; native definition of function "py_import" omitted
    (bind "py-import" (special_form py_import)) 
    (bind "py_import" py_import) ;; native definition of function "__lookup" omitted
    (bind "." (special_form __lookup)) 
    (bind "__lookup" __lookup) 
    (bind quote_fun_name (special_form (fn (env e) e))) 
    (let* ((backquote_level_var "*__backquote_level*"))) 
    (defun source_eval (env form) 
      (set form (__eval env form)) 
      (__eval env form)) 
    (bind "eval" (special_form source_eval)) 
    (defun macroexpand1 (env form) 
      (assert (is_operator_call form) form) 
      (let* ((fun (macro_fun (__eval env (1st form))))) 
        (return (__macroexpand_1 env fun (tail form))))) 
    (defun macroexpand (env form) 
      (assert (is_operator_call form) form) 
      (let* ((fun (macro_fun (__eval env (1st form))))) 
        (return (__macroexpand env fun (tail form))))) 
    (bind "macroexpand-1" (special_form macroexpand1)) 
    (bind "macroexpand" (special_form macroexpand)) 
    (bind "set" (special_form __setq)) 
    (bind "__sub-env" (special_form __sub_env)) 
    (bind "progn" (special_form __progn)) 
    (bind "def" (special_form __def)) 
    (bind "defun" (special_form __defun)) 
    (bind "defmacro" (special_form __defmacro)) 
    (bind "fn" (special_form (fn (env parameters &rest body) 
                                 (apply __fn ` (~ env ~ parameters ~ nil ~@ body))))) 
    (bind "apply" (special_form __apply)) 
    (bindn "callable?" "is_callable" is_callable) 
    (bind "gensym" (special_form (fn (env &rest args) 
                                     (apply gensym args)))) 
    (bind "null?" (fn 
                   (&rest 
                    args) 
                   (all (map (fn (e) 
                                 (is e nil)) args)))) 
    (let* ((tests (dict :symbol is_symbol 
                        :keyword is_keyword 
                        :list is_list 
                        :tuple is_tuple 
                        :dict is_dict 
                        :num is_num 
                        :float is_float 
                        :int is_int 
                        :str is_str 
                        :atom is_atom))) 
      (dolist ((:= k f) 
               (as-list (tests.items))) 
        (bind ((. "{s}?" format) :s k) f) 
        (bind ((. "is_{s}" format) :s k) f)) 
      (bind "named-operator?" is_named_operator) 
      (defun numeric_op (op) 
        (defun numeric_op (a &rest args) 
          (let* ((r a)) 
            (dolist (b args) 
              (set r (op r b))) 
            (return r)))
        numeric_op) 
      (bind "+" (numeric_op operator.__add__)) 
      (bind "-" (numeric_op operator.__sub__)) 
      (bind "*" (numeric_op operator.__mul__)) 
      (bind "/" (numeric_op operator.__truediv__)) 
      (bind "mod" (numeric_op operator.__mod__)) 
      (bind "eq" operator.__eq__) 
      (bind "neq" operator.__ne__) ;; native definition of function "__is" omitted
      (bind "__is" __is) 
      (bind "not" operator.__not__) 
      (defun _and (env &rest tests) 
        (let* ((r nil)) 
          (dolist (test tests) 
            (set r (__eval env test)) 
            (unless r (return nil))) 
          (return r))) 
      (bind "and" (special_form _and)) 
      (defun _or (env &rest tests) 
        (let* ((r nil)) 
          (dolist (test tests) 
            (set r (__eval env test)) 
            (when r (return r))))
        nil) 
      (bind "or" (special_form _or))) 
    (bind "<" operator.__lt__) 
    (bind "<=" operator.__le__) 
    (bind ">" operator.__gt__) 
    (bind ">=" operator.__ge__) 
    (defun cons (e l) 
      (assert (is_list l) 
              (repr l)) 
      (+ (list e) l)) 
    (bind "cons" cons) ;; native definition of function "slice" omitted
    (bind "slice" slice) 
    (bind "length" length) ;; native definition of function "contains" omitted
    (bindn "contains?" "contains" contains) 
    (defun nth (i l) 
      (assert (or (is_list l) 
                  (is_tuple l) 
                  (is_str l)) 
              ((. "nth: {i} {l} ({t})" format) :i (sexps_str i) 
               :l (sexps_str l) 
               :t (type l))) 
      (aref l i)) 
    (bind "nth" nth) 
    (defun tail (l) 
      (tail l)) 
    (bind "tail" tail) 
    (bind "defstruct" (special_form defstruct)) 
    (bind "__defstruct" __defstruct)
    (let* ((catch-throw-tag 'internal-exception))
      (defun _throw (env tag value)
        (let* ((tag (__eval env tag))
               (value (__eval env value)))
          (throw catch-throw-tag (cons tag value)))) 
      (bind "throw" (special_form _throw))

      (defun _catch (env tag &rest body)
        (let* ((tag (__eval env tag)))
          (apply catch `(~catch-throw-tag ~@body))
          ))
      (bind "catch" (special_form _catch)))

    (defun exception (s) 
      (Exception s)) 
    (bind "Exception" exception) 
    (defun file_open (filename mode) 
      (when (is_symbol mode) 
        (set mode (symbol_name mode))) 
      (assert (is_str mode)) 
      (file-open filename mode)) 
    (bind "file-open" file_open) 
    (bind "argv" args) 
    (py-import pathlib) 
    (bind "make-Path" pathlib.Path) 
    (defun print_ 
        (&rest 
         args) 
      (apply print args)) 
    (bind "print" print_) 
    (defun princ (arg) 
      (ps arg)) 
    (bind "princ" princ) 
    (bind "host_function_name" function_name) 
    (bind "is_host_function" is_function) 
    (bind "native_set_nokeys" native_set_nokeys) 
    (bind "int" int) 
    (bind "float" float) 
    (bind "str" str) 
    (defun py_with (env _with &rest body) 
      (assert (is_list _with)) 
      (assert (eq (length _with) 1)) 
      (set _with (1st _with)) 
      (let* ((var nil)) 
        (when (is_list _with) 
          (assert (eq (length _with) 2)) 
          (let* ((__gensym-let-value-3 _with)) 
            (set var (aref __gensym-let-value-3 0)) 
            (set _with (aref __gensym-let-value-3 1))) 
          (assert (is_symbol var))) 
        (py-with ((f (__eval env _with))) 
                 (when (is-not var nil) 
                   (env_def env var f)) 
                 (apply __progn ` (~ env ~@ body))))) 
    (bind "py-with" (special_form py_with)) 
    (bind "read" read) 
    (set env (make_env env)) 
    (env_def env global_env_sym env) 
    (py-with ((f (file-open "stdlib.lisp" "r"))) 
             (interpret (read (Stream (f.read) 0)) env)) 
    (set env (make_env env)) 
    (env_def env global_env_sym env) 
    (return env)))
(defun __progn (env &rest forms) 
  (let* ((r nil)) 
    (dolist (form forms) 
      (set r (__eval env form))) 
    (return r)))
(defun _interpret (forms (env nil) 
                         (args (list))) 
  (when (is env nil) 
    (set env (base_env args))) 
  (assert env env) 
  (env_def env (intern "__name__") "<self>") 
  (apply __progn ` (~ env ~@ forms)))
(def native_interpret _interpret)
;; native definition of function "native_interpret" omitted

(def interpret _interpret)
(py-import unittest)
(py-import argparse)
(def reader_tests (list (tuple "" (list)) 
                        (tuple "1" (list 1)) 
                        (tuple "1.0" (list 1.0)) 
                        (tuple "()" (list (list))) 
                        (tuple "(1)" (list (list 1))) 
                        (tuple "(1 2)" (list (list 1 2))) 
                        (tuple "(foo)" (list (list (intern "foo")))) 
                        (tuple "(foo bar)" (list (list (intern "foo") 
                                                       (intern "bar")))) 
                        (tuple "(1+)" (list (list (intern "1+")))) 
                        (tuple "(())" (list (list (list)))) 
                        (tuple "((list a b ()))" (list (list (list (intern "list") 
                                                                   (intern "a") 
                                                                   (intern "b") 
                                                                   (list))))) 
                        (tuple "'a" (list (list (intern quote_fun_name) 
                                                (intern "a")))) 
                        (tuple "'()" (list (list (intern quote_fun_name) 
                                                 (list)))) 
                        (tuple "()1" (list (list) 1)) 
                        (tuple "'()1" (list (list (intern quote_fun_name) 
                                                  (list)) 1)) 
                        (tuple "`()" (list (list (intern backquote_fun_name) 
                                                 (list)))) 
                        (tuple "`~foo" (list (list (intern backquote_fun_name) 
                                                   (list (intern backquote_eval_fun_name) 
                                                         (intern "foo"))))) 
                        (tuple "`(~foo)" (list (list (intern backquote_fun_name) 
                                                     (list (list (intern backquote_eval_fun_name) 
                                                                 (intern "foo")))))) 
                        (tuple "`(bar ~foo)" (list (list (intern backquote_fun_name) 
                                                         (list (intern "bar") 
                                                               (list (intern
                                                                      backquote_eval_fun_name) 
                                                                     (intern "foo")))))) 
                        (tuple "`(bar ~foo baz)" (list (list (intern backquote_fun_name) 
                                                             (list (intern "bar") 
                                                                   (list (intern
                                                                          backquote_eval_fun_name) 
                                                                         (intern "foo")) 
                                                                   (intern "baz"))))) 
                        (tuple "`(bar ~@ foo baz)" (list (list (intern backquote_fun_name) 
                                                               (list (intern "bar") 
                                                                     (list (intern
                                                                            backquote_splice_fun_name) 
                                                                           (intern "foo")) 
                                                                     (intern "baz"))))) 
                        (tuple "a.b" (list (list (intern ".") 
                                                 (intern "a") 
                                                 (intern "b")))) 
                        (tuple ";a" (list)) 
                        (tuple "(;a\n)" (list (list))) 
                        (tuple "'() ;1" (list (list (intern quote_fun_name) 
                                                    (list)))) 
                        (tuple "(defun foo () (+ 1 2)) (foo)" (list (list (intern "defun") 
                                                                          (intern "foo") 
                                                                          (list) 
                                                                          (list (intern "+") 1 2)) 
                                                                    (list (intern "foo")))) 
                        (tuple "(set p ((. a b)))" (list (list (intern "set") 
                                                               (intern "p") 
                                                               (list (list (intern ".") 
                                                                           (intern "a") 
                                                                           (intern "b"))))))))
(defun get_process_args () 
  (print "Getting process args" argv)
  argv)
;; native definition of function "get_process_args" omitted

(def p (argparse.ArgumentParser))
(p.add_argument "--type")
(p.add_argument "--num" 
                :type int)
(p.add_argument "-c" 
                :nargs "+")
(p.add_argument "args" 
                :nargs "*")
(def args (p.parse_args (get_process_args)))
(def tests_file "tests.lisp")
(defun load_tests () 
  (let* ((tests nil)) 
    (py-with ((f (file-open tests_file "r"))) 
             (set tests (f.read))) 
    (set tests (read (Stream tests 0))) 
    (return tests)))
(cond ((and 
        (is-not args.type nil) 
        (is-not args.num nil)) 
       (when (eq args.type "reader") 
         (def program (1st (aref reader_tests args.num))) 
         (ps program) 
         (ps (read (Stream program 0)))) 
       (when (eq args.type "interpreter") 
         (def tests (load_tests)) 
         (def program (1st (aref tests args.num))) 
         (print "Program:" (sexps_str program)) 
         (ps (interpret program)))) 
      (args.c (dolist (filename args.c) 
                (py-with ((f (file-open filename "r"))) 
                         (def program (f.read))) 
                (print "Result:" (interpret (read (Stream program 0)) 
                                            :args args.args)))) 
      (true (def tests (load_tests)) 
            (def test_results (list)) 
            (defun run_test (test) 
              (tuple true (interpret test))) 
            (dolist ((:= itest (test result)) 
                     (enumerate tests)) 
              (print ((. "================ RUNNING test {i} ================" format) :i itest)) 
              (print (sexps_str test)) 
              (test_results.append (run_test test))) 
            (dolist ((:= itest (success r)) 
                     (reversed (as-list (enumerate test_results)))) 
              (unless success (print ((.
                                       "^^^^ Test {i} failed. ^^^^\n    {test}\nexpected:\n    {expected}\nbut got:\n    {r}"
                                       format) :i itest 
                                       :test (sexps_str (1st (aref tests itest))) 
                                       :expected (sexps_str (2nd (aref tests itest))) 
                                       :r r)) 
                      (when (isinstance r Exception) 
                        (traceback.print_tb r.__traceback__)))) 
            (print ((. "{nfailed} of {n} tests succeeded." format) :nfailed (length (filter (fn
                                                                                             (success
                                                                                              r) 1)
                                                                                            test_results
                                                                                            success)) 
                    :n (length test_results)))))
